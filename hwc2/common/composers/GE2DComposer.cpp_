/*
// Copyright(c) 2016 Amlogic Corporation
*/
#include <HwcTrace.h>
#include <HwcFenceControl.h>
#include <GE2DComposer.h>
#include <IDisplayDevice.h>
#include <inttypes.h>

#define GE2D_PORCESS_DEBUG

namespace android {
namespace amlogic {

GE2DComposer::GE2DComposer(IDisplayDevice& disp)
    : Composers(disp),
      mDisplayDevice(disp),
      mLock(),
      mCondition(),
      mSyncTimelineFd(-1),
      mBufferMask(0),
      mNumBuffers(1),
      mFbSlot(0),
      mCurGlesFbSlot(-1),
      mSingleFbSize(0),
      mGe2dBufHnd(NULL),
      mSrcBufferInfo(NULL),
      mExitThread(false),
      mInitialized(false)
{
    mName = "GE2D";

    mQueue.setCapacity(8);
    mQueue.clear();
}

GE2DComposer::~GE2DComposer()
{
    WARN_IF_NOT_DEINIT();
}

int32_t GE2DComposer::allocBuffer(private_module_t* module, size_t size, int32_t usage, buffer_handle_t* pHandle)
{
    ion_user_handle_t ion_hnd;
    unsigned char *cpu_ptr = NULL;
    int32_t shared_fd;
    int32_t ret;
    int32_t ion_flags = 0;
    int32_t lock_state = 0;

#if 1 // no need cache.
    if ( (usage & GRALLOC_USAGE_SW_READ_MASK) == GRALLOC_USAGE_SW_READ_OFTEN )
    {
        ion_flags = ION_FLAG_CACHED | ION_FLAG_CACHED_NEEDS_SYNC;
    }
#endif

    if (usage & GRALLOC_USAGE_AML_DMA_BUFFER)
    {
        ret = ion_alloc(module->ion_client, size, 0, ION_HEAP_CARVEOUT_MASK,
                    ion_flags, &ion_hnd);
    }

    if ( ret != 0)
    {
        ETRACE("Failed to ion_alloc from ion_client:%d", module->ion_client);
        return -1;
    }

    ret = ion_share( module->ion_client, ion_hnd, &shared_fd );
    if ( ret != 0 )
    {
        ETRACE( "ion_share( %d ) failed", module->ion_client );
        if ( 0 != ion_free( module->ion_client, ion_hnd ) )
            ETRACE( "ion_free( %d ) failed", module->ion_client );
        return -1;
    }

    if (!(usage & GRALLOC_USAGE_PROTECTED))
    {
        cpu_ptr = (unsigned char*)mmap( NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, shared_fd, 0 );

        if ( MAP_FAILED == cpu_ptr )
        {
            ETRACE( "ion_map( %d ) failed", module->ion_client );
            if ( 0 != ion_free( module->ion_client, ion_hnd ) )
                ETRACE( "ion_free( %d ) failed", module->ion_client );
            close( shared_fd );
            return -1;
        }
        lock_state = private_handle_t::LOCK_STATE_MAPPED;
    }

    private_handle_t *hnd = new private_handle_t( private_handle_t::PRIV_FLAGS_USES_ION /*TODO ion extend*| priv_heap_flag*/, usage, size, cpu_ptr,
                                                    lock_state );

    if ( NULL != hnd )
    {
        hnd->share_fd = shared_fd;
        hnd->ion_hnd = ion_hnd;
        /*TODO ion extend hnd->min_pgsz = min_pgsz; */
        *pHandle = hnd;
        return 0;
    }
    else
    {
        ETRACE( "Gralloc out of mem for ion_client:%d", module->ion_client );
    }

    close( shared_fd );

    if (!(usage & GRALLOC_USAGE_PROTECTED))
    {
        ret = munmap( cpu_ptr, size );
        if ( 0 != ret )
            ETRACE( "munmap failed for base:%p size: %zd", cpu_ptr, size );
    }

    ret = ion_free( module->ion_client, ion_hnd );
    if ( 0 != ret )
        ETRACE( "ion_free( %d ) failed", module->ion_client );
    return -1;
}

void GE2DComposer::freeBuffer(private_handle_t const* hnd, private_module_t* m)
{
	if ( hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION )
	{
		/* Buffer might be unregistered already so we need to assure we have a valid handle*/
		if ( 0 != hnd->base )
		{
			if ( 0 != munmap( (void*)hnd->base, hnd->size ) ) ETRACE( "Failed to munmap handle %p", hnd );
		}
		close( hnd->share_fd );
		if ( 0 != ion_free( m->ion_client, hnd->ion_hnd ) ) ETRACE( "Failed to ion_free( ion_client: %d ion_hnd: %p )", m->ion_client, hnd->ion_hnd );
		memset( (void*)hnd, 0, sizeof( *hnd ) );
	}
}

bool GE2DComposer::initialize(framebuffer_info_t* fbInfo)
{
    Mutex::Autolock _l(mLock);

    if (mInitialized) {
        WTRACE("object has been initialized");
        return true;
    }

    // create a release fence timeline.
    mSyncTimelineFd = HwcFenceControl::createFenceTimeline();
    if (mSyncTimelineFd == -1) {
        DEINIT_AND_RETURN_FALSE("sync timeline create failed!");
    }
    mCurrentSyncTime = 1;

    // create ge2d composer thread.
    mExitThread = false;
    mThread = new GE2DRenderThread(this);
    if (!mThread.get()) {
        DEINIT_AND_RETURN_FALSE("failed to create ge2d composer thread.");
    }
    mThread->run("GE2DComposer", PRIORITY_URGENT_DISPLAY);

    // framebuffer stuff.
    mFbInfo = fbInfo;
    mSingleFbSize = fbInfo->finfo.line_length
            * fbInfo->info.yres;
    mNumBuffers = fbInfo->fbSize / mSingleFbSize;

    mSrcBufferInfo = new aml_ge2d_info_t();

    // ge2d init.
    ge2d_init();
    mInitialized = true;
    return true;
}

void GE2DComposer::deinitialize()
{
    mExitThread = true;
    mCondition.signal();

    if (mThread.get()) {
        mThread->requestExitAndWait();
        mThread = NULL;
    }

    if (mSrcBufferInfo != NULL) {
        delete mSrcBufferInfo;
        mSrcBufferInfo = NULL;
    }

    // ge2d exit.
    ge2d_exit();
    mInitialized = false;
}

const char* GE2DComposer::getName() const
{
    return mName;
}

const uint32_t GE2DComposer::getFbSlot()
{
    Mutex::Autolock _l(mLock);

    return mFbSlot;
}

void GE2DComposer::setCurGlesFbSlot(uint32_t slot) {
    Mutex::Autolock _l(mLock);

    mCurGlesFbSlot = slot;
}

uint32_t GE2DComposer::findFreeFbSlot()
{
    int32_t fbSlot = 0;

	if (mNumBuffers == 1) {
		// If we have only one buffer, we never use page-flipping.
		return 0;
	}

    if (-1 != mCurGlesFbSlot) {
        // mBufferMask = 0x0;
        // If gles composer just before come here, we should avoid this buffer and prior buffer.
        fbSlot = mCurGlesFbSlot +  2 * mFbInfo->info.yres;
        if (fbSlot % (3*mFbInfo->info.yres) == 0) {
            mBufferMask = 0x1;
        } else if (fbSlot % (3*mFbInfo->info.yres) == 1) {
            mBufferMask = 0x7;
        } else if (fbSlot % (3*mFbInfo->info.yres) == 2) {
            mBufferMask = 0x3;
        }

        /*for (uint32_t i= 0; i<(fbSlot % (3*mFbInfo->info.yres)) / mFbInfo->info.yres + 1; i++) {
            mBufferMask |= (1LU<<i);
        }*/
        mCurGlesFbSlot = -1;
        ETRACE("Stark, mNumBuffers: %d, mBufferMask: 0x%x", mNumBuffers, mBufferMask);
    } else {
        if (mBufferMask >= ((1LU<<mNumBuffers)-1)) {
    		// We ran out of buffers. reinit to 0;
    		mBufferMask = 0x1;
            return 0;
    	}

        // find a free slot
        for (uint32_t i=0 ; i<mNumBuffers ; i++) {
            if ((mBufferMask & (1LU<<i)) == 0) {
                mBufferMask |= (1LU<<i);
                break;
            }

            fbSlot += 2 * mFbInfo->info.yres;
        }
    }

    return fbSlot % (3*mFbInfo->info.yres);
}

int32_t GE2DComposer::startCompose(Vector< hwc2_layer_t > hwcLayers, int32_t *offset)
{
    Mutex::Autolock _l(mLock);
    if (NULL != mGe2dBuffer) {
        int32_t usage = GRALLOC_USAGE_AML_DMA_BUFFER;
        int32_t ret = allocBuffer(mFbInfo->grallocModule, mFbInfo->fbSize, usage, &mGe2dBufHnd);
        if (ret < 0) {
            ETRACE("allocBuffer failed!");
            return ALLOC_BUFFER_FAILED;
        }
    } else {
        DTRACE("Buffer alloced already.");
    }

    // find a free slot of fb.
    mFbSlot = findFreeFbSlot();
    *offset = mFbSlot;

    // add hwcLayers to work queue.
    mQueue.push_back(hwcLayers);

    int32_t ge2dFence = HwcFenceControl::createFence(mSyncTimelineFd, "ge2d_flag", mCurrentSyncTime++);
    int32_t layersMergedFence = -1;
    int32_t ge2dMergedFence = -1;

    // wait all layers fence here.
    for (uint32_t i=0; i<hwcLayers.size(); i++) {
        hwc2_layer_t layerId = hwcLayers.itemAt(i);
        HwcLayer* hwcLayer = mDisplayDevice.getLayerById(layerId);
        if (hwcLayer != NULL) {
            int32_t duppedFence = hwcLayer->getDuppedAcquireFence();
            int32_t tempFence = -1;

            tempFence = HwcFenceControl::merge(String8("layers_merged"), duppedFence, layersMergedFence);
            HwcFenceControl::closeFd(layersMergedFence);
            layersMergedFence = tempFence;

            // wait layers to be drawed here.
            HwcFenceControl::waitAndCloseFd(duppedFence, 5000);
            // HwcFenceControl::closeFd(duppedFence);
        }
    }
    mCondition.signal();

    // merge layer's fences and ge2d fence.
    ge2dMergedFence = HwcFenceControl::merge(String8("ge2d_flag"), layersMergedFence, ge2dFence);
    DTRACE("ge2d merged fence: %d", ge2dMergedFence);

    HwcFenceControl::closeFd(ge2dFence);
    HwcFenceControl::closeFd(layersMergedFence);

    return ge2dMergedFence;
}

// test.
void GE2DComposer::directMemcpy(Fifo::iterator front)
{
    uintptr_t buffer = (uintptr_t)mFbInfo->grallocModule->fb_primary.framebuffer->base;

    // ge2d work here.
    for (uint32_t i=0; i<front->size(); i++) {
        // do ge2d compose.
        hwc2_layer_t layerId = front->itemAt(i);
        HwcLayer* hwcLayer = mDisplayDevice.getLayerById(layerId);
        ETRACE("thread loop to do ge2d work here.");

        if (hwcLayer != NULL) {
            // video overlay.
            private_handle_t const* hnd =
                reinterpret_cast<private_handle_t const*>(hwcLayer->getBufferHandle());
            if (hnd != NULL) {
                // common memcpy mode.
                if (private_handle_t::validate(hnd) < 0) {
                    ETRACE("invalid layer handle.");
                    continue;
                }
                void* fBuffer = (void*)(buffer + mSingleFbSize * (mFbSlot/mFbInfo->info.yres));
                ETRACE("hnd->stride is %d, hnd->height is %d, hnd->size: %d, hnd->base: 0x%llx, mSingleFbSize: %d, Slot: %d, buffer: 0x%llx",
                    hnd->stride, hnd->height, hnd->size, (uintptr_t)hnd->base, mSingleFbSize, mFbSlot/mFbInfo->info.yres, (uintptr_t)fBuffer);
                if (fBuffer != MAP_FAILED) {
                    memset(fBuffer, 0, mSingleFbSize);
                    memcpy(fBuffer, hnd->base, hnd->size);
                    ETRACE("copy ok");
                } else {
                    ETRACE("buffer mmap fail");
                }
            }
        }
    }
}

#if 0
void GE2DComposer::runGE2DProcess(HwcLayer* hwcLayer)
{
    // ge2d work here.
    DTRACE("thread loop to do ge2d work here.");
    hwc_frect_t sourceCrop;
    hwc_rect_t displayFrame;
    private_handle_t const* hnd =
        reinterpret_cast<private_handle_t const*>(hwcLayer->getBufferHandle());
    if (hnd != NULL) {
        sourceCrop = hwcLayer->getSourceCrop();
        displayFrame = hwcLayer->getDisplayFrame();

        mSrcBufferInfo->src_info[0].paddr = getIonPhyAddr(mFbInfo, hnd);
        mSrcBufferInfo->src_info[0].format = hnd->format;
        // mSrcBufferInfo->src_info[0].rotation = hwcLayer->getTransform();

        mSrcBufferInfo->src_info[0].rect.x = (int)sourceCrop.left;
        mSrcBufferInfo->src_info[0].rect.y = (int)sourceCrop.top;
        mSrcBufferInfo->src_info[0].rect.w = (int)(sourceCrop.right - displayFrame.left);
        mSrcBufferInfo->src_info[0].rect.h = (int)(sourceCrop.bottom- displayFrame.top);
        mSrcBufferInfo->src_info[0].canvas_w = hnd->stride;
        mSrcBufferInfo->src_info[0].canvas_h = hnd->height;

        mSrcBufferInfo->src_info[0].memtype = CANVAS_ALLOC;

        // src1 equals dst.
        mSrcBufferInfo->src_info[1].rect.x = 0;
        mSrcBufferInfo->src_info[1].rect.y = 0;
        mSrcBufferInfo->src_info[1].rect.w = mFbInfo->info.xres;
        mSrcBufferInfo->src_info[1].rect.h = mFbInfo->info.yres;
        mSrcBufferInfo->src_info[1].memtype = CANVAS_OSD0;

        mSrcBufferInfo->blend_mode = hwcLayer->getBlendMode();

        mSrcBufferInfo->dst_info.rect.x = displayFrame.left;
        mSrcBufferInfo->dst_info.rect.y = displayFrame.top;
        mSrcBufferInfo->dst_info.rect.w = displayFrame.right - displayFrame.left;
        mSrcBufferInfo->dst_info.rect.h = displayFrame.bottom - displayFrame.top;
        mSrcBufferInfo->dst_info.memtype = CANVAS_OSD0;
        mSrcBufferInfo->dst_info.rotation = hwcLayer->getTransform();
    }

    // ge2d processing.
    if (0 == mSrcBufferInfo->blend_mode)
        mSrcBufferInfo->ge2d_op = AML_GE2D_STRETCHBLIT;
    else
        mSrcBufferInfo->ge2d_op = AML_GE2D_BLEND;

#ifdef GE2D_PORCESS_DEBUG
    nsecs_t beforeTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
#endif
    ge2d_process(mSrcBufferInfo);
#ifdef GE2D_PORCESS_DEBUG
    nsecs_t afterTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
    ETRACE("ge2d process Period: %" PRId64 "", afterTimeStamp - beforeTimeStamp);
    ETRACE("Src1 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
        "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
        mSrcBufferInfo->src_info[0].canvas_w, mSrcBufferInfo->src_info[0].canvas_h,
        mSrcBufferInfo->offset, mSrcBufferInfo->src_info[0].format, mSrcBufferInfo->blend_mode,
        mSrcBufferInfo->src_info[0].rect.x, mSrcBufferInfo->src_info[0].rect.y,mSrcBufferInfo->src_info[0].rect.w,mSrcBufferInfo->src_info[0].rect.h,
        mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
    ETRACE("Src2 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
        "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
        mSrcBufferInfo->src_info[1].canvas_w, mSrcBufferInfo->src_info[1].canvas_h,
        mSrcBufferInfo->offset, mSrcBufferInfo->src_info[1].format, mSrcBufferInfo->blend_mode,
        mSrcBufferInfo->src_info[1].rect.x, mSrcBufferInfo->src_info[1].rect.y,mSrcBufferInfo->src_info[1].rect.w,mSrcBufferInfo->src_info[1].rect.h,
        mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
#endif
}

#else
void GE2DComposer::runGE2DProcess(HwcLayer* hwcLayer1, HwcLayer* hwcLayer2)
{
    bool sameSourceCrop = false;
    bool swapLayers = false;    
    hwc_frect_t sourceCrop[2];
    HwcLayer* layer[2];
    private_handle_t const* hnd[2];
    nsecs_t beforeTimeStamp = 0, afterTimeStamp = 0;
    hwc_rect_t displayFrame;
    uint32_t layerNum = GE2D_COMPOSE_ONE_LAYER;

    layer[0] = hwcLayer1;
    layer[1] = hwcLayer2;

    if (layer[1] != NULL) {
        layerNum = GE2D_COMPOSE_TWO_LAYERS;
        sourceCrop[0] = layer[0]->getSourceCrop();
        sourceCrop[1] = layer[1]->getSourceCrop();
        if ((int32_t)sourceCrop[0].left == (int32_t)sourceCrop[1].left
                && (int32_t)sourceCrop[0].top == (int32_t)sourceCrop[1].top
                && (int32_t)sourceCrop[0].right == (int32_t)sourceCrop[1].right
                && (int32_t)sourceCrop[0].bottom == (int32_t)sourceCrop[1].bottom) {
            sameSourceCrop = true;
        }

        if (sameSourceCrop && 0 != layer[1]->getBlendMode() && 0 == layer[0]->getBlendMode()) {
            layer[0] = hwcLayer2;
            layer[1] = hwcLayer1;
            swapLayers = true;
        }
    }

    for (int32_t i=0; i<layerNum; i++) {
        hnd[i] = reinterpret_cast<private_handle_t const*>(layer[i]->getBufferHandle());
    }

    if (sameSourceCrop && swapLayers) {
        if (hnd[0] != NULL && hnd[1] != NULL) {
            for (int32_t i=0; i<layerNum; i++) {
                ETRACE("hnds: %p, %p", hnd[0], hnd[1]);
                mSrcBufferInfo->src_info[i].paddr = getIonPhyAddr(mFbInfo, hnd[i]);
                mSrcBufferInfo->src_info[i].format = hnd[i]->format;
                mSrcBufferInfo->src_info[i].rect.x = (int32_t)sourceCrop[i].left;
                mSrcBufferInfo->src_info[i].rect.y = (int32_t)sourceCrop[i].top;
                mSrcBufferInfo->src_info[i].rect.w = (int32_t)(sourceCrop[i].right - sourceCrop[i].left);
                mSrcBufferInfo->src_info[i].rect.h = (int32_t)(sourceCrop[i].bottom- sourceCrop[i].top);
                mSrcBufferInfo->src_info[i].canvas_w = hnd[i]->stride;
                mSrcBufferInfo->src_info[i].canvas_h = hnd[i]->height;
                mSrcBufferInfo->src_info[i].memtype = CANVAS_ALLOC;
            }
            mSrcBufferInfo->blend_mode = layer[0]->getBlendMode();
            displayFrame = layer[0]->getDisplayFrame();

            mSrcBufferInfo->dst_info.rect.x = displayFrame.left;
            mSrcBufferInfo->dst_info.rect.y = displayFrame.top;
            mSrcBufferInfo->dst_info.rect.w = displayFrame.right - displayFrame.left;
            mSrcBufferInfo->dst_info.rect.h = displayFrame.bottom - displayFrame.top;
            mSrcBufferInfo->dst_info.memtype = CANVAS_OSD0;
        }
        mSrcBufferInfo->dst_info.rotation = layer[0]->getTransform();

        // ge2d processing.
        mSrcBufferInfo->ge2d_op = AML_GE2D_BLEND;
#ifdef GE2D_PORCESS_DEBUG
        nsecs_t beforeTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
#endif
        ge2d_process(mSrcBufferInfo);
#ifdef GE2D_PORCESS_DEBUG
        nsecs_t afterTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
        ETRACE("Same SourceCrop ge2d process Period: %" PRId64 "", afterTimeStamp - beforeTimeStamp);

        ETRACE("Same SourceCrop Src1 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
            "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
            mSrcBufferInfo->src_info[0].canvas_w, mSrcBufferInfo->src_info[0].canvas_h,
            mSrcBufferInfo->offset, mSrcBufferInfo->src_info[0].format, mSrcBufferInfo->blend_mode,
            mSrcBufferInfo->src_info[0].rect.x, mSrcBufferInfo->src_info[0].rect.y,mSrcBufferInfo->src_info[0].rect.w,mSrcBufferInfo->src_info[0].rect.h,
            mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
        ETRACE("Same SourceCrop Src2 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
            "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
            mSrcBufferInfo->src_info[1].canvas_w, mSrcBufferInfo->src_info[1].canvas_h,
            mSrcBufferInfo->offset, mSrcBufferInfo->src_info[1].format, mSrcBufferInfo->blend_mode,
            mSrcBufferInfo->src_info[1].rect.x, mSrcBufferInfo->src_info[1].rect.y,mSrcBufferInfo->src_info[1].rect.w,mSrcBufferInfo->src_info[1].rect.h,
            mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
#endif
    } else {
        if (layerNum == GE2D_COMPOSE_TWO_LAYERS && hnd[1] == NULL) {
            ETRACE("two layers compose, hnd should not be null");
            return;
        }
        for (int32_t i=0; i<layerNum; i++) {
            mSrcBufferInfo->src_info[0].paddr = getIonPhyAddr(mFbInfo, hnd[i]);
            mSrcBufferInfo->src_info[0].format = hnd[i]->format;
            mSrcBufferInfo->src_info[0].rect.x = (int32_t)sourceCrop[i].left;
            mSrcBufferInfo->src_info[0].rect.y = (int32_t)sourceCrop[i].top;
            mSrcBufferInfo->src_info[0].rect.w = (int32_t)(sourceCrop[i].right - sourceCrop[i].left);
            mSrcBufferInfo->src_info[0].rect.h = (int32_t)(sourceCrop[i].bottom- sourceCrop[i].top);
            mSrcBufferInfo->src_info[0].canvas_w = hnd[i]->stride;
            mSrcBufferInfo->src_info[0].canvas_h = hnd[i]->height;
            mSrcBufferInfo->src_info[0].memtype = CANVAS_ALLOC;

            // src1 equals dst.
            mSrcBufferInfo->src_info[1].rect.x = 0;
            mSrcBufferInfo->src_info[1].rect.y = 0;
            mSrcBufferInfo->src_info[1].rect.w = mFbInfo->info.xres;
            mSrcBufferInfo->src_info[1].rect.h = mFbInfo->info.yres;
            mSrcBufferInfo->src_info[1].memtype = CANVAS_OSD0;
            mSrcBufferInfo->blend_mode = layer[i]->getBlendMode();

            displayFrame = layer[i]->getDisplayFrame();
            mSrcBufferInfo->dst_info.rect.x = displayFrame.left;
            mSrcBufferInfo->dst_info.rect.y = displayFrame.top;
            mSrcBufferInfo->dst_info.rect.w = displayFrame.right - displayFrame.left;
            mSrcBufferInfo->dst_info.rect.h = displayFrame.bottom - displayFrame.top;
            mSrcBufferInfo->dst_info.memtype = CANVAS_OSD0;
            mSrcBufferInfo->dst_info.rotation = layer[i]->getTransform();

            // ge2d processing.
            if (0 == mSrcBufferInfo->blend_mode)
                mSrcBufferInfo->ge2d_op = AML_GE2D_STRETCHBLIT;
            else
                mSrcBufferInfo->ge2d_op = AML_GE2D_BLEND;
#ifdef GE2D_PORCESS_DEBUG
            nsecs_t beforeTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
#endif
            ge2d_process(mSrcBufferInfo);
#ifdef GE2D_PORCESS_DEBUG
            nsecs_t afterTimeStamp = systemTime(SYSTEM_TIME_MONOTONIC);
            ETRACE("Ge2d process Period: %" PRId64 "", afterTimeStamp - beforeTimeStamp);
            ETRACE("Src1 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
                "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
                mSrcBufferInfo->src_info[0].canvas_w, mSrcBufferInfo->src_info[0].canvas_h,
                mSrcBufferInfo->offset, mSrcBufferInfo->src_info[0].format, mSrcBufferInfo->blend_mode,
                mSrcBufferInfo->src_info[0].rect.x, mSrcBufferInfo->src_info[0].rect.y,mSrcBufferInfo->src_info[0].rect.w,mSrcBufferInfo->src_info[0].rect.h,
                mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
            ETRACE("Src2 stride is %d, height is %d, Slot: %d, format: %d, blendMode: %d, "
                "srcCrop: [%d, %d, %d, %d], displayFrame:[%d, %d, %d, %d]",
                mSrcBufferInfo->src_info[1].canvas_w, mSrcBufferInfo->src_info[1].canvas_h,
                mSrcBufferInfo->offset, mSrcBufferInfo->src_info[1].format, mSrcBufferInfo->blend_mode,
                mSrcBufferInfo->src_info[1].rect.x, mSrcBufferInfo->src_info[1].rect.y,mSrcBufferInfo->src_info[1].rect.w,mSrcBufferInfo->src_info[1].rect.h,
                mSrcBufferInfo->dst_info.rect.x, mSrcBufferInfo->dst_info.rect.y, mSrcBufferInfo->dst_info.rect.w, mSrcBufferInfo->dst_info.rect.h);
#endif
        }
    }
}
#endif

bool GE2DComposer::threadLoop()
{
    Mutex::Autolock _l(mLock);
    mCondition.wait(mLock);
    if (mExitThread) {
        ITRACE("exiting thread loop");
        return false;
    }

    DTRACE("Stark, sync timeline fd : %d", mSyncTimelineFd);
    Fifo::iterator front(mQueue.begin());
    while (mQueue.size() > 0) {
        // direct memcpy mode test.
        // directMemcpy(front);

        // do ge2d compose.
        // ETRACE("thread loop to do ge2d work here.");
        hwc2_layer_t layerId = front->itemAt(0);
        HwcLayer* hwcLayer = mDisplayDevice.getLayerById(layerId);
        switch (front->size()) {
            case GE2D_COMPOSE_ONE_LAYER:
            {
                // run one layer ge2d process.
                if (hwcLayer != NULL) {
                    mSrcBufferInfo->offset = mFbSlot;
                    runGE2DProcess(hwcLayer, NULL);
                }
            }
            break;
            case GE2D_COMPOSE_TWO_LAYERS:
            {
                // run 2 layers ge2d process.
                hwc2_layer_t layerId2 = front->itemAt(1);
                HwcLayer* hwcLayer2 = mDisplayDevice.getLayerById(layerId2);

                // run two layers ge2d process.
                if (hwcLayer != NULL && hwcLayer2 != NULL) {
                    mSrcBufferInfo->offset = mFbSlot;
                    runGE2DProcess(hwcLayer, hwcLayer2);
                }
            }
            break;
            case GE2D_COMPOSE_THREE_LAYERS:
            default:
                ETRACE("More than 2 layers exists, ge2d can't do that process!");
            break;
        }

        // signal ge2d's release fence.
        HwcFenceControl::syncTimelineInc(mSyncTimelineFd);

        mQueue.erase(front);
        front = mQueue.begin();
    }

    return true;
}

} // namespace amlogic
} // namesapce android

